## Итоговое занятие №10

### Тема: JavaScript. Асинхронные операции. Основы ООП.
Репозитарий содержит материалы по итоговому занятию №10, посвященному работе с асинхронными операциями в JavaScript.

### Цели занятия
- закрепление знаний, полученных на лекциях;
- практическое применение знаний, полученных на лекциях.

### Разогрев
1. Что выведет код:
```
class Test {
  constructor() {
    this.testName = 'Timon';
  }
}

const first = new Test();
console.log(first.testName);
const second = first;
second.testName = 'Pumba';
console.log(first.testName);
```

2. Что выведет код:
```
class Test {
  constructor() {
    this.testName = 'Timon';
  }

  method() {
    setTimeout( () => {
      this.testName = 'Pumba';
    }, 0);
  }
}

const first = new Test();
console.log(first.testName);
first.method();
console.log(first.testName);
```

3. Что выведет код:
```
class Test {
  constructor(name) {
    this.name = name;
  }

  method() {
    console.log(this.name);
  }
}

const first = new Test('Timon');
const second = {
  name: 'Pumba',
  method: first.method
}

first.method();
second.method();

```

4. Что выведет код:
```
class AsyncClass {

  constructor(name, delay) {
    console.log('Constructor' + name);
    this.name = name;
    this.delay = delay;
  }

  handle() {
    return new Promise( resolve => {
      setTimeout( () => { resolve(this.name) }, this.delay * 1000 );
    });
  }
}

const first = new AsyncClass('First', 2);
const second = new AsyncClass('Second', 3);
Promise.all( [first.handle(), second.handle() ] )
  .then( result => { console.log(result.join(' ')); } );
```

### Задачи занятия

1. У нас есть массив с рабочими предприятия, которые работают на конвейере и собирают машины. У каждого объекта с данными рабочего, есть функция `work` - рабочий выполняет свою часть работы. Эта функция возвращает промис, который будет зарезолвлен той деталью, которую делает этот рабочий. Нужно написать функцию `assembleCar`, которая будет принимать на вход массив рабочих. Она пройдется по массиву рабочих, запустит для каждого его функцию `work`, соберет результаты в массив, и вернет этот массив.
2. Открыли новый цех, и на него набрали рабочих меньшей квалификации - они иногда косячат. Нужно, чтобы конвейер в случае брака выводил бы сообщение о причине отвержения. То есть, если один из этапов сборки пошел не по плану - то вся машина собрана не будет.
3. Переходим к ООП. Дорабатываем систему контроля версий. Реализуем у класса `VersionsControl` методы:
 - `major` - увеличить major на 1, а в minor и patch поставить 0.
 - `minor` - увеличить minor на 1, а в patch поставить 0.
 - `patch` - увеличить patch на 1.
4. Реализуем возможность истории версий. Нам нужно вести историю версий, т.е. при каждом изменении версии (вызове метода major, minor, patch) сохранять текущую версию.
5. Реализуем метод `rollback` - то есть откат к предыдущей версии.
6. Пишем класс `Queue`, который будет реализовывать простую очередь. Ему нужны методы `enqueue`, `dequeue`, то есть, положить что-то в очередь, и извлечь из очереди. Логика работы очереди - "первый зашел, первый вышел".
7. Теперь реализуем класс `Stack`. У него должны быть методы `get`, `put`. Тут логика работы "последний зашел - первый вышел".
8. Теперь переходим к работе с графикой. Нам нужно реализовать функциональность, которая будет работать с DOM-узлами. Первым таким элементом будет заголовок. Создаем класс `Heading`, который будет отвечать за заголовок. В конструкторе он должен принять тег (`h1`-`h6`), и текст заголовка. Конструктор должен создать DOM-элемент (только создать, не добавляя на страницу!).
9. Добавляем метод `render`. Он должен принять в аргументе строку с селектором, найти на странице элемент по этому селектору, и в него добавить наш DOM-узел. При этом, рекомендуется проверить, удалось ли найти такой элемент. Если нет - то кинуть исключение.
10. Усложним метод `render`. Теперь, кроме селектора, он должен принимать еще один аргумент, который будет указывать, куда конкретно в элемент-контейнер нужно добавить наш параграф. Имеется в виду `append`, `prepend`, `before`, `after`.
11. Создадим класс `Dropdown`, который будет отвечать за рендеринг выпадающих списков. В конструкторе он будет принимать id и имя (значение атрибута name) для создаваемого селекта. Также, ему в свойствах нужно дать пустой массив опций.
12. Добавляем ему метод `setOptions`. Он должен принять массив объектов-опций, имя свойства ключа, и имя свойства значения, и записать в соответствующие свойства (`optionKey`, `optionValue`) нашего объекта.
13. Пишем метод `render`. В аргументах он также примет селектор контейнера, и флаг, куда конкретно добавлять (как с параграфом). Его задача - пройтись по `options`, для каждой опции создать элемент `<option>`. Нужно, чтобы у опции в качестве `value` использовалось свойство с таким ключом, который мы записали в свойство `optionKey` в п.10, а текст - это значение свойства `optionValue`.