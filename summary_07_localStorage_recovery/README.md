## Итоговое занятие №7

### Тема: JavaScript. Повторение изученного ранее. LocalStorage.
Репозитарий содержит материалы по итоговому занятию №7, посвященному работе с localStorage.

### Цели занятия
- закрепление знаний, полученных на лекциях;
- практическое применение знаний, полученных на лекциях.

### Задачи занятия

### Работа с localStorage
Решаем задачи, оставшиеся с предыдущего занятия - работаем с DOM и localStorage.
1. Верстка формы обратной связи. От нас требуется с помощью JS (методами работы с DOM), создать и добавить на страницу форму обратной связи. Предполагается, что форма имеет следующие поля:
   - фамилия
   - имя
   - емейл
   - телефон
   - кнопка "Отправить"
   - кнопка "Отмена"
2. Обеспечение сохранения имени пользователя при обновлении страницы, и при показе формы, если значение указано - заполняем соответствующий инпут.
3. Обеспечение сохранения данных полей формы при обновлении страницы, и заполнение значениями при показе формы. Здесь суть задачи в том, что нужно обеспечить сохранение в ЛС данных ВСЕХ инпутов (то есть, динамически пройтись по всем инпутам на странице, и сохранить в ЛС). Перед решением задачи, обсуждаем пути решения.
4. Обеспечение очистки данных формы при нажатии "Отмена" - т.е. если пользователь нажал "Отмена", то очищаем localStorage
5. Задача на повторение. Нужно написать блок кода, который создаст объект, в котором ключами будут значения атрибутов `name` инпутов, а значениями - значения инпутов.

### Регулярные выражения в JavaScript
! Обязательно к [прочтению](https://learn.javascript.ru/regexp-introduction) - подробнейший раздел учебника по регулярным выражениям !

Регулярные выражения (regular expression, RegEx) - это средство поиска шаблонов в строках. Оно позволяет не просто искать вхождение подстроки по совпадению, а задавать более сложные критерии отбора.

Регулярное выражение состоит из шаблона и необязательных флагов. В JavaScript любое регулярное выражение является объектом класса RegEx. То есть - предоставляет определенный интерфейс методов для работы с поисками подстрок и т.д.

В чем основная "прелесть" регэкспов? В том, что мы можем задать более сложные условия поиска. Например, проверить, что строка содержит цифры в определенном формате. Или проверить шаблон емейла. Или проверить шаблон номера телефона. И многое другое.

Как это работает? Мы создаем шаблон регулярного выражения (т.е. то, с чем мы хотим сопоставлять нашу строку). Затем, нам нужно вызвать метод сопоставления, и он нам вернет результат - "подходит" ли искомая строка под шаблон.

Пример. Давайте напишем регулярное выражение, которое проверяет, что в строке есть цифры.
```
// Объявляем регулярное выражение. То, что внутри слэшей - это шаблон поиска.
// \d - это шаблон поиска любой цифры (0,1,2,...,9)
const hasDigit = /\d/;

const str = 'str without digits';
const str2 = 'str 1 with digits';

console.log(hasDigit.test(str)); // false
console.log(hasDigit.test(str2)); // true
```

Таким образом, мы делаем вывод, что мы можем писать шаблоны сопоставления строк (поиска подстроки). Шаблонов ОЧЕНЬ много (есть справочники), их можно комбинировать и собирать тот, который нужен в конкретном случае. Мы рассмотрим самые популярные.
 - \d - любая цифра от 0 до 9 (именно ЦИФРА!)
 - \D - любой символ КРОМЕ цифры
 - \w - любая буква латинского алфавита без учета регистра, любая цифра, и символ подчеркивания
 - \W - все, КРОМЕ букв латинского алфавита, цифр, и символа подчеркивания
 - \s - пробельные символы (пробел, табуляция, перенос строки)
 - \S - все, КРОМЕ пробельных символов

Закрепим практикой.
1. Написать регэксп, который проверяет, содержит ли строка букву.
2. Написать регэксп, который проверяет, что строка НЕ содержит цифры.

Далее. Просто искать в строке скучно - иногда важна последовательность, и количество вхождений. С помощью регэкспов, мы можем сказать: "проверь, что строка начинается с цифры", или "проверь, что строка заканчивается на букву". Это достигается использованием специальных символов.
 - ^ - начало строки
 - $ - конец строки

```
const startsFromDigit = /^\d/;
const str = 'timon123';
const str2 = '1pumba';
console.log(startsFromDigit.test(str)); // false
console.log(startsFromDigit.test(str2)); // true
const endsByLetterOrDigit = /\w$/;
const str3 = 'timon123';
const str4 = '1pumba ';
console.log(endsByLetterOrDigit.test(str3)); // true
console.log(endsByLetterOrDigit.test(str4)); // false
```

Также, мы можем указывать наборы или диапазоны поиска. Например, мы можем сказать "проверь, что строка начинается на гласную". То есть, что начало строки начинается на одну из букв диапазона A,a,O,o,E,e,I,i,U,u,Y,y.
```
const startsFromVovel = /^[AaOoIiUuYyEe]/;
const str1 = 'Toyota';
const str2 = 'toyota';
const str3 = 'Opel';
const str4 = 'opel';
console.log(startsFromVovel.test(str1)); // false
console.log(startsFromVovel.test(str2)); // false
console.log(startsFromVovel.test(str3)); // true
console.log(startsFromVovel.test(str4)); // true
```

Таким образом, мы указываем диапазон значений. Причем, в диапазоне можно указывать и ранее рассмотренные шаблоны.
```
const startsFromDigitOrLetter = /^[\d\w]/;
const str1 = 'Toyota';
const str2 = '1toyota';
const str3 = 'Opel';
const str4 = ' opel';
console.log(startsFromDigitOrLetter.test(str1));
console.log(startsFromDigitOrLetter.test(str2));
console.log(startsFromDigitOrLetter.test(str3));
console.log(startsFromDigitOrLetter.test(str4));
```

Закрепим практикой.
1. Написать регэксп, который проверяет, что строка начинается с четной цифры.
2. Проверить, что строка заканчивается НЕ на пробельный символ, и НЕ на цифру.
3. Проверить, что строка начинается на заглавную гласную букву, и заканчивается на маленькую букву. (Задача с подвохом).

В регэкспах также можно проверять количество вхождений. Для этого, существуют квантификаторы. То есть, мы можем указывать, сколько раз входит какой-то символ. Например, мы хотим сказать: "проверь, что в начале строки 4 цифры".
```
const startRegex = /^\d{4}/;
```

или "проверь, что строка заканчивается на одну или более цифр".
```
const endRegex = /\d+$/;
```

Мы видим здесь квантификаторы. Рассмотрим самые востребованные:
 - символ "+" - одно и более вхождений.
 - символ "?" - это ноль или одно вхождение
 - символ "*" - это ноль или более вхождений
 - {n} - точно n вхождений
 - {n,m} - вхождения от n до m
 - {n,} - вхождения от n и более

Попробуем написать регэксп, который будет проверять номер телефона (давайте рассмотрим украинский формат). Мы видим, что украинский формат - это символ "+", за ним идет код страны (380), далее идет код оператора (2 цифры), и далее собственно номер (7 цифр). То есть, нам нужно проверить, что наша строка начинается на "+380", и затем идет 9 цифр.
```
const phoneUa = /^\+380\d{9}$/;
const uaPhone = "+380991234567";
const ruPhone = "+79991234567";
console.log(phoneUa.test(uaPhone)); // true
console.log(phoneUa.test(ruPhone)); // false
```

То есть, мы говорим: "нужно, чтобы строка начиналась с +380, затем шло 9 цифр, и строка заканчивалась". Обратите внимание, что символ "+" в начале строки экранирован (слэшем), то есть мы говорим что хотим найти именно символ "+", это не квантификатор.

Закрепим практикой.
1. Написать регэксп, который проверяет, является ли строка номером карты. Это 4 блока по 4 цифры, разделенные пробелами. 1234-4321-1234-4321.
2. Написать регэксп, который проверяет, что номер телефона - в немецком формате (начинается на +48, и дальше идет 11 цифр).
3. Усложним регэксп из задачи 2. Добавим скобки и пробелы, чтобы код оператора был в скобках и отделен пробелами: +48-(1111)-1234321.