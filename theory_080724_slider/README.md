## Теоретическое занятие 08.07.2024

### Тема: Повторение методов работы с DOM в JavaScript.

Репозитарий содержит материалы по теоретическому занятию, посвященному работе с DOM.

### Цели занятия
- решение задачи со слайдером
- теоретические материалы по погружению/всплытию событий в JS

### Часть 1. Решение задачи со слайдером.

1. С предыдущего занятия, есть разметка и стили для слайдера. Нам осталось только реализовать управление текущим слайдом, т.е. смену картинки. Для этого, нам понадобится управлять смещением контейнера `.cards_container` относительно "рамки" слайдера (`frame`). Задача к обсуждению.
2. Реализуем то, что обсудили в первой задаче, добавляем обработчики на кнопки `.triggers > button`. Делаем плавный переход между слайдами.
3. Реализуем внизу иконки, отображающие текущий слайд. Нужно, чтобы внизу (под слайдером), отображалась бы панель с точками, которые показывали бы количество слайдов. Активный слайд нужно подсветить. Для этого, воспользуемся классами `slider_dot`, `active`, которые уже определены в стилях.
4. Задача к обсуждению. Сделать так, чтобы при клике на точку, слайдер переходил бы на соответствующий слайд.

### Часть 2. Теоретический материал. Погружение и всплытие событий.
Сегодня будем говорить о механизме распространения событий (event propagation) в JS. В это понятие входят такие фазы, как погружение и всплытие. О них и будем говорить.

И начнем с наглядного примера. Имеем разметку:
```
<div id="myDiv" onclick="console.log('click on DIV')">
  <button id="myButton" >Click Me!</button>
</div>
```

Нажмем на кнопку. И мы увидим в консоли сообщение, которое выводится обработчиком нашего div. Почему же так произошло?

Такое явление происходит как раз за счет распространения события. Что бы это значило? Рассмотрим всю цепочку "с нуля".

Когда мы делаем какое-то действие: кликаем мышкой, перемещаем курсор, нажимаем клавишу на клавиатуре, и т.д. - браузер "под капотом" генерирует объект события (`Event`). Этот объект будет содержать массу полезной (и не очень) информации о событии: тип события, детали, где произошло (на каком элементе), и многое другое.

В зависимости от типа события, эта информация будет отличаться:
 - при событии клика, объект события содержит координаты клика.
 - В случае с событием клавиатуры (например, нажатие клавиши `keydown`) - объект события содержит информацию о том, какую конкретно клавишу нажали.

И так далее. И мы можем с этим работать в обработчиках события. Но об этом чуть позже.

Теперь что же происходит с этим объектом, после того, как он был создан браузером? А дальше он начинает "путешествие" к тому DOM-элементу, который его "спровоцировал". Что имеется в виду: объект события идет сквозь ВСЮ иерархию DOM-узлов, сверху вниз, от тега `html` до того элемента, который его вызвал. В нашем примере, это будет элемент `button`. И получается, что конкретно в нашем примере, имеем такой маршрут:
`<html> -> <body> -> <div#myDiv> -> <button#myButton>`

Это фаза погружения. То есть, объект события генерится браузером, и затем "погружается" в глубину DOM-дерева к целевому (target) элементу, который его вызвал. В нашем примере - к кнопке, по которой мы кликнули.

А после этого, идет фаза "всплытия". Когда объект события, как пузырек воздуха, всплывает из глубины DOM-дерева наверх. То есть, проходит весь маршрут из фазы погружения, но в обратном направлении. Это можно также сравнить с поездкой в лифте: сначала мы "погружаемся" в кабину, затем перемещаемся по "цепочке" этажей до целевого, там что-то делаем, и затем возвращаемся тем же путем - то есть проезжаем все этажи в обратном порядке.

При этом, мы можем на любом этапе (на любом этаже), добавить свой обработчик события. Попробуем: добавим обработчики события клика на кнопку, и на весь документ в целом. Пусть это будет просто вывод в консоль. И кликнем на кнопку.

Как мы видим, все 3 обработчика сработали. Это подтверждает нашу теорию про "путешествие" объекта события. Но нужно обратить внимание на:
 - последовательность сработки обработчиков
 - тот факт, что обработчики сработали по ОДНОМУ разу

Почему так? Потому что по умолчанию, события обрабатываются на фазе всплытия. То есть "на обратном пути". Это реально изменить - нужно при добавлении обработчика (обязательно через `addEventListener`), передать ему третий аргумент, `true` - то есть маркер того, что это событие следует обработать на фазе погружения.

Зачем нам нужно погружение и всплытие? Основной вариант использования - это прием под названием "делегирование событий". Это ситуация, когда мы хотим выполнять некую одинаковую логику при наступлении какого-то события в каком-то множестве DOM-элементов. И вместо прямого назначения обработчика события каждому элементу дерева, мы можем "делегировать" эту обработку ближайшему общему предку.

Пример: мы хотим сделать трекер кликов, то есть отслеживать, какие DOM-элементы нашей страницы кликают наши пользователи, и вести протокол. Это реальный кейс, для всяких оптимизаций, аналитик, поисковых роботов и т.д. Как можно было бы дейстовать: написать функцию `trackClick`, которая будет выполнять нашу логику, и навесить на каждый интересующий нас DOM-элемент обработчик события клика. Но это долго и неэффективно. Есть вариант получше: "делегировать" обработку событий ближайшему общему предку. Например, тегу `body`, или вообще документу в целом. Тогда мы одной строчкой добавляем обработку событий и отслеживаем все, что хотим.

Можем ли мы обрабатывать эти события на уровне документа, и при этом понимать, где конкретно произошло это событие (т.е. кто его спровоцировал)? Да запросто. Как мы помним, каждый объект события содержит массу полезной информации. И в числе прочего, он содержит свойство `target`, которое как раз и указывает на тот DOM-элемент, который спровоцировал событие.

И еще момент. Возвращаясь к примеру с лифтом, мы можем в любой момент нажать "Стоп", и на каком-то из этапов предотвратить дальнейшее движение. То есть, мы можем запретить дальнейшее всплытие. Для этого у каждого объекта события есть метод `stopPropagation`. Он как раз и предотвращает всплытие. Но пользоваться им нужно очень аккуратно, и с полным понимаем того, что вы делаете. При прекращении всплытия, события дальше не идут, и обработчики на "родительских" элементах уже не узнают об этих событиях. А чаще всего, на родительских элементах добавляются обработчики, которые отвечают за аналитику, трекинг действий пользователя, и прочее. И это может мешать их нормальной работе. Так что предотвращение всплытия используем аккуратно.

### Задачи на закрепление
1. Есть разметка:
```
<div>
  <button>First button</button>
  <button>Second button</button>
  <button>Third button</button>
<div>
```

И есть функция
```
const btnClickHandler = (e) => console.log('Clicked on Button!');
```

Нужно сделать так, чтобы эта функция вызывалась при клике на любую кнопку, в любом месте нашего div.

2. Усложним задачу. Добавим в наш div пару инпутов. И покликаем по ним. Как мы видим, обработчик тоже вызывается. Давайте это исправим. Нам нужно, чтобы наш обработчик вызывался только при клике по кнопкам. То есть, нам нужно как-то "игнорировать" те события, которые генерируются не инпутами. Здесь нам поможет то, что объект события хранит в себе информацию о том, какой DOM-элемент его спровоцировал (свойство `target`). А каждый DOM-элемент знает о своем типе - в свойстве `tagName` хранится имя тега в верхнем регистре.

3. Давайте представим что мы злобные хакеры, и пишем кейлоггер, то есть хотим отслеживать события клавиатуры на сайте. Нам нужно написать функцию `trackKeyboard`, которая будет отслеживать нажатия клавиш (причем неважно, где фокус), и выводит в консоль, что же конкретно нажато. Нас будет интересовать свойство `key` объекта события. И нужно разместить обработчик в правильном месте.

4. И теперь усложним задачу 2. Добавим кнопкам 1 и 3 класс `active`. И наша задача - реагировать только на те кнопки, у которых есть этот класс.

### Полезные ссылки по занятию:
 - [Всплытие событий](https://learn.javascript.ru/bubbling-and-capturing) - максимально полезная информация по всплытию событий, настоятельно рекомендуется к прочтению.