# README

## Лекционное занятие от 10.09.2024

### Тема:

Репозитарий содержит материалы по лекционному занятию, посвященному работе с хуком useContext.

Занятие посвящено работе с хуком `useContext` в React. Сначала, поймем мотивацию - зачем вообще это нужно, и что такое контекст. Если очень грубо, то контекст можно воспринимать как среду, в которой выполняется какой-то код. Как пример, рыба плавает в воде. Функция "плавание" выполняется объектом класса "Рыба" в контексте "водная среда". В этой среде, доступна вода (о которую опираются плавники), доступны течения, доступно дно, и т.д. А вот в контексте "суша" этого всего нет, и функция "плавание" выполняться не будет. То есть, контекст можно рассматривать как некоторую среду (окружение), которая что-то содержит, в которой выполняется какая-то задача, и эта задача имеет доступ к этому содержимому.

Теперь, поговорим о мотивации введения понятия "контекст" в React.js. Ранее, мы обсуждали прием под названием "подъем состояния" (lifting state). Это прием, который заставлял нас поднять состояние, которое мы хотим "разделить" между несколькими компонентами, до ближайшего их общего предка. Чем это нехорошо?

Давайте предположим, что у нас очень "развесистая" иерархия компонентов приложения, которая содержит множество уровней. На нижнем уровне, у нас есть компоненты "инпут", "параграф". Например, так:

App - WelcomePage - LoginForm - Input, Paragraph
    - RegisterPage - RegisterForm - Input, Paragraph

Их ближайшим общим предком будет компонент `App` (то есть, самый верх). И мы вводим понятие "тема приложения". Нам нужно, чтобы тема приложения была доступна и инпуту, и параграфу. Как мы помним, в этом случае нам нужно "поднять" фрагмент стейта, который отвечает за тему приложения, на уровень компонента `App` - то есть на уровень ближайшего общего предка.

Вроде все норм. Но есть нюанс. Теперь, когда у нас на уровне `App` объявлена тема
```
const [theme, setTheme] = useState('light');
```

, нам нужно как-то передать эту тему вниз, в компоненты "инпут", "параграф". Нам придется пробрасывать этот проп через ВСЮ иерархию компонентов - то есть App - WelcomePage - LoginForm - Input, Paragraph. И точно так же для формы регистрации. То есть, мы пробрасываем проп через компоненты, которые в этом пропе НЕ нуждаются. Это не особо хорошо. Основная причина - теперь при изменении темы, будут перерисовываться не только инпуты и параграфы, а все приложение (потому что мы перерисовываем компонент `App`, и как следствие - всех его потомков). Да и не особо удобно пробрасывать пропсы через всю иерархию компонентов, которые в этих пропсах не нуждаются.

Эта проблема называется **prop drilling**.

Что же делать в этом случае? Тут нам на помощь приходит понятие контекста, и хук `useContext`. Этот хук помещает компонент в указанный контекст. Проводя аналогию с рыбой, помещает рыбу (компонент) в нужный водоем (контекст).

Контекст будет "прицельно" предоставлять необходимые данные конкретным компонентам, независимо от их места в иерархии.

Тут сразу есть важный момент. Сам по себе хук `useContext` работать не будет. Мы ведь должны указать, в какой конкретно водоем мы помещаем нашу рыбу. Поэтому, нам еще нужно предварительно создать этот контекст, и затем поместить нужный компонент в этот контекст.

Собираем все вместе. Разбирать будем на примере темы приложения (это один из наиболее часто встречаемых вариантов использования контекста). У нас в папке проекта `inputViews`, есть компоненты, которые планируется темизировать (то есть в зависимости от темы приложения, применять разные стили). Реализуем это с помощью контекста.

Первое - это создание контекста. Создадим новую папку в проекте, `context`, и там создадим контекст темы. Назовем его `ThemeContext.jsx`. В нем, мы должны создать контекст. Содержимое файла `ThemeContext.jsx` будет таким:
```
// Импортируем функцию из "стандартного пакета" React, которая позволит нам создать контекст
import { createContext } from 'react';

// Создаем контекст. Аргумент - это начальное значение, "последний шанс" - то есть то значение, которое будет использовано
// если не найдено никаких других вариантов - о них далее.
export const ThemeContext = createContext('light');
```

Второе - это воспользоваться контекстом.


### Полезные ссылки по занятию:
 - [React useEffect](https://react.dev/reference/react/useEffect#updating-state-based-on-previous-state-from-an-effect) - толковая официальная документация по `useEffect`. С интерактивными примерами, поэтому настоятельно рекомендуется к просмотру. Кое-что там можно проигнорировать (например использование анимации), но в целом дает представление о том, зачем это.
 - [React useEffect](https://ru.legacy.reactjs.org/docs/hooks-effect.html) - устаревшая, зато русскоязычная документация. Она все еще актуальна, логика работы хука никак не изменилась, так что можно рассмотреть.