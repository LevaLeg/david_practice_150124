# README

## Лекционное занятие от 10.09.2024

### Тема:

Репозитарий содержит материалы по лекционному занятию, посвященному работе с хуком useContext.

**Введение**
Занятие посвящено работе с хуком `useContext` в React. Сначала, поймем мотивацию - зачем вообще это нужно, и что такое контекст. Если очень грубо, то контекст можно воспринимать как среду, в которой выполняется какой-то код. Как пример, рыба плавает в воде. Функция "плавание" выполняется объектом класса "Рыба" в контексте "водная среда". В этой среде, доступна вода (о которую опираются плавники), доступны течения, доступно дно, и т.д. А вот в контексте "суша" этого всего нет, и функция "плавание" выполняться не будет. То есть, контекст можно рассматривать как некоторую среду (окружение), которая что-то содержит, в которой выполняется какая-то задача, и эта задача имеет доступ к этому содержимому.

**Понятие контекста. Проблематика, которая решается контекстом**
Теперь, поговорим о мотивации введения понятия "контекст" в React.js. Ранее, мы обсуждали прием под названием "подъем состояния" (lifting state). Это прием, который заставлял нас поднять состояние, которое мы хотим "разделить" между несколькими компонентами, до ближайшего их общего предка. Чем это нехорошо?

Давайте предположим, что у нас очень "развесистая" иерархия компонентов приложения, которая содержит множество уровней. На нижнем уровне, у нас есть компоненты "инпут", "параграф". Например, так:

App - WelcomePage - LoginForm - Input, Paragraph
    - RegisterPage - RegisterForm - Input, Paragraph

Их ближайшим общим предком будет компонент `App` (то есть, самый верх). И мы вводим понятие "тема приложения". Нам нужно, чтобы тема приложения была доступна и инпуту, и параграфу. Как мы помним, в этом случае нам нужно "поднять" фрагмент стейта, который отвечает за тему приложения, на уровень компонента `App` - то есть на уровень ближайшего общего предка.

Вроде все норм. Но есть нюанс. Теперь, когда у нас на уровне `App` объявлена тема
```
const [theme, setTheme] = useState('light');
```

, нам нужно как-то передать эту тему вниз, в компоненты "инпут", "параграф". Нам придется пробрасывать этот проп через ВСЮ иерархию компонентов - то есть App - WelcomePage - LoginForm - Input, Paragraph. И точно так же для формы регистрации. То есть, мы пробрасываем проп через компоненты, которые в этом пропе НЕ нуждаются. Это не особо хорошо. Основная причина - теперь при изменении темы, будут перерисовываться не только инпуты и параграфы, а все приложение (потому что мы перерисовываем компонент `App`, и как следствие - всех его потомков). Да и не особо удобно пробрасывать пропсы через всю иерархию компонентов, которые в этих пропсах не нуждаются.

Эта проблема называется **prop drilling**.

Что же делать в этом случае? Тут нам на помощь приходит понятие контекста, и хук `useContext`. Этот хук помещает компонент в указанный контекст. Проводя аналогию с рыбой, помещает рыбу (компонент) в нужный водоем (контекст).

Контекст будет "прицельно" предоставлять необходимые данные конкретным компонентам, независимо от их места в иерархии.

Тут сразу есть важный момент. Сам по себе хук `useContext` работать не будет. Мы ведь должны указать, в какой конкретно водоем мы помещаем нашу рыбу. Поэтому, нам еще нужно предварительно создать этот контекст, и затем поместить нужный компонент в этот контекст.

**Использование хука useContext**
Собираем все вместе. Разбирать будем на примере темы приложения (это один из наиболее часто встречаемых вариантов использования контекста). У нас в папке проекта `inputViews`, есть компоненты, которые планируется темизировать (то есть в зависимости от темы приложения, применять разные стили). Реализуем это с помощью контекста.

Первое - это создание контекста. Создадим новую папку в проекте, `context`, и там создадим контекст темы. Назовем его `ThemeContext.jsx`. В нем, мы должны создать контекст. Содержимое файла `ThemeContext.jsx` будет таким:
```
// Импортируем функцию из "стандартного пакета" React, которая позволит нам создать контекст
import { createContext } from 'react';

// Создаем контекст. Аргумент - это начальное значение, "последний шанс" - то есть то значение, которое будет использовано
// если не найдено никаких других вариантов - о них далее.
export const ThemeContext = createContext('light');
```

Второе - это воспользоваться контекстом. Для этого, нам нужен хук `useContext`. Мы должны применить его в компонентах, которые должны пользоваться контекстом. Рассмотрим на примере компонента `SimpleInput`.

```
import { useContext } from "react";
import { ThemeContext } from "../context/ThemeContext";

function SimpleInput( {placeholder, value, onChange} ) {
  const ctx = useContext(ThemeContext);

  return (
    <input
      value={value}
      className={`simpleInput ${ctx}`}
      onChange={onChange}
      placeholder={placeholder}
    />
  );
}

export default SimpleInput;
```

То есть, наш компонент теперь пользуется контекстом `ThemeContext`. Аналогичные действия произведем в `SimpleHeader`.

Чего мы добились по итогу? Теперь наши темизированные компоненты успешно работают с контекстом. Есть еще один шаг, который нам нужно сделать - это сделать провайдер контекста. Зачем - потому что контекст может иметь разные значения. Это значит, что мы можем не задавать один контекст на все приложение, а задавать разным "областям" приложения контексты одного типа, но с разным значением. Пока звучит абстрактно - рассмотрим на примере.

Предположим, что мы хотим сделать темизацию компонентов на уровне всего приложения светлой, а на уровне формы авторизации (`LoginForm`) - темной. При текущем "раскладе" мы так сделать не можем, потому что хук `useContext` в наших компонентах всегда будет иметь значение `light` (по умолчанию). Давайте сделаем так, чтобы в `LoginForm` был бы свой контекст, в который будут обернуты все его потомки.

Теперь, в компоненте `LoginForm`, мы создаем провайдер контекста (то есть конкретный аквариум, в который будем помещать рыбу).
```
<ThemeContext.Provider value="dark">
 <div className="loginForm">
  <SimpleHeader textContent="LoginForm"/>
  ...
</ThemeContext.Provider>
```

И вот у нас уже есть конкретный провайдер контекста, который предоставляет содержимому компонета `LoginForm` конкретный контекст, который содержит значение "dark" - то есть темная тема. И мы видим, что все заголовки вне `LoginForm` у нас светлые, а тот что в форме - с темной темой. То есть, мы создали провайдер контекста с конкретным значением контекста, и обернули его вокруг формы логина.

Возникает вопрос: а что, если у нас несколько вложенных контекстов? Как тогда? В этом случае, реакт возьмет значение из ближайшего провайдера контекста по иерархии предков. Если же он не нашел ни одного провайдера контекста - то он возьмет значение, который был изначально инициализирован контекст при вызове `createContext`.

**Закрепим практикой**
1. Создадим контекст настроек приложения. Нам нужно создать контекст `SettingsContext`, который будет содержать строку (типа 16px). Она отвечает за размер шрифтов в приложении. Нужно, чтобы мы пользовались этим контекстом в компонентах `ProductCard`, `SimpleHeader` - устанавливаем размер шрифта для заголовка с названием товара и для заголовка в SimpleHeader как значение из этого контекста.
 - создаем контекст `SettingsContext` в отдельном файле в папке `context`.
 - подключаем контекст в нужных компонентах с использованием хука `useContext`.
 - создаем провайдер контекста, в который обернем их ближайшего общего предка (компонент `App`).

2. Немного усложним, а заодно убедимся, что в контексте может быть все, что угодно. Теперь в контексте `SettingsContext`, нам нужно хранить объект со свойствами `heading1`, `heading2`, `heading3` - то есть теперь у нас есть разные размеры шрифтов для разных заголовков (h1, h2, h3 соответственно). И воспользуемся этим в наших компонентах.

**Управление контекстом**
Зачастую, бывают ситуации, когда нам мало просто один раз объявить контекст, и просто им пользоваться. Зачастую, мы хотим еще и управлять значением, которое хранится в контексте. В примере с темой приложения - мы можем захотеть (и наверняка захотим!), добавить возможность поменять тему приложения. Как это реализовать?

По сути, для самого контекста ничего не поменялось. Меняться будет только значение, используемое в провайдере контекста. Раньше, мы использовали что-то примитивное, и забитое жестко. А теперь, давайте попробуем воспользоваться чем-то таким, что при изменении перерисует компонент и всех его потомков. Похоже на хук `useState`, не так ли? Воспользуемся им для управления контекстом.

```
// App.js
const themeContext = useContext(themeContext);
const [theme, setTheme] = useState('light');

// ...
return (
  // ...
  <ThemeContext.Provider value={ {theme, setTheme} } >
    // код компонента App
  </ThemeContext.Provider>
)
```

Теперь нам осталось только в нужные моменты времени вызывать `setTheme`, и компонент будет работать так, как задумывалось.

### Полезные ссылки по занятию:
 - [React Context](https://react.dev/learn/passing-data-deeply-with-context) - растолкование понятия контекста. Тоже толково, интерактивно, с примерами.
 - [React useContext](https://react.dev/reference/react/useContext) - о хуке в целом, с примерами и интерактивом. Интерес представляет подраздел по управлению значением контекста.